<?php

/**
 * @file
 * Lingotek Community Translation Hooks, Added Fields on Node Creation
 */

include_once ('lingotek.session.inc');
include_once ('lingotek.reference.inc');
include_once ('lingotek.util.inc');
include_once ('lingotek.api.inc');
include_once ('lingotek.sync.inc');
include_once ('lingotek.mt.inc');

/*
 * Implementation of hook_menu
 */
function lingotek_menu() {
  $items = array();

  $items['admin/settings/lingotek'] = array(
    'title' => 'Lingotek',
    'access arguments' => array('lingotek administration page'),
    'description' => 'Community Translation Settings',
    'file' => 'lingotek.admin.inc',
    'page callback' => 'lingotek_settings_page',
  );

  $items['node/%node/lingotek_pm'] = array(
    'title' => 'Lingotek',
    'access arguments' => array('lingotek content progress tab'),
    'file' => 'lingotek.page.inc',
    'page arguments' => array(1),
    'page callback' => 'lingotek_summary',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  $items['lingotek/update'] = array(
    'access arguments' => array('flush translations from lingotek'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_update',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/mt_all'] = array(
    'access arguments' => array('lingotek administration page'),
    'file' => 'lingotek.page.inc',
    'page callback' => 'lingotek_mt_all',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/segment'] = array(
    'access arguments' => array('machine translation'),
    'file' => 'lingotek.mt.inc',
    'page callback' => 'lingotek_mt_save_segment',
    'type' => MENU_CALLBACK,
  );

  $items['lingotek/mt'] = array(
    'access arguments' => array('machine translation'),
    'file' => 'lingotek.mt.inc',
    'page callback' => 'lingotek_mt',
    'type' => MENU_CALLBACK,
  );

  $items['admin/settings/lingotek/dev'] = array(
    'title' => 'Lingotek Developer Tools',
    'access arguments' => array('lingotek developer features'),
    'description' => 'Developer Tools',
    'file' => 'lingotek.dev.inc',
    'page callback' => 'lingotek_dev_page',
  );

  $items['node/%node/lingotek_dev'] = array(
    'title' => 'Lingotek Developer Tools',
    'access arguments' => array('lingotek developer features'),
    'description' => 'Developer Tools',
    'file' => 'lingotek.dev.inc',
    'page callback' => 'lingotek_dev_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/*
 * Implementation of hook_permission
 */
function lingotek_perm() {
  return array('content progress tab', 'administration page', 'translate content', 'review translations', 'flush translations from lingotek', 'machine translation', 'content creation added options', 'lingotek developer features');
}

/*
 * Implementation of hook_form_alter
 */
function lingotek_form_alter(&$form, $form_state, $form_id) {
  if (isset($form['#id']) && strpos($form['#id'], 'node-form') !== FALSE && isset($form['#node']->type)) {
    $nid = $form['#parameters'][2]->nid;
    //Only give options if the node is new
    if (!isset($nid)) {
      $form['lingotek'] = array(
        '#title' => t('Lingotek Settings'),
        '#type' => 'fieldset', '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#description' => t("These settings can only be set once, when creating the page."),
        '#access' => user_access('content creation added options'),
      );
      $form['lingotek']['phaseTemplate'] = array(
        '#type' => 'select',
        '#title' => t('Phase Template'),
        '#default_value' => variable_get('lingotek_phase_template', ''),
        '#options' => lingotek_get_phase_templates(),
      );
    }
  }
}

/*
 * Implementation of hook_nodeapi
 */
function lingotek_nodeapi($node, $op, $teaser, $page) {
  if ($node->language == "") {
    $node->language = variable_get('lingotek_neutral_language', 'en');
  }
  switch ($op) {
    case 'view':
      $view_mode = '';
      if ($page) {
        $view_mode = 'full';
      }
      lingotek_node_view($node, $view_mode);
      break;

    case 'update':
      lingotek_node_update($node);
      break;

    case 'delete':
      lingotek_node_delete($node);
      break;

    case 'insert':
      lingotek_node_insert($node);
      break;
  }
}

/*
 * nodeapi update
 */
function lingotek_node_update($node) {
  global $_lingotek_client;

  $doc_id = lingotek_lingonode($node->nid, 'document_id');
  if ($doc_id == FALSE) {
    return;
  }

  $xml = "<?xml version=\"1.0\"?><contents><title><![CDATA[" . $node->title . "]]></title><body><![CDATA[" . $node->body . "]]></body></contents>";

  $_lingotek_client->request('updateContentDocument', array('documentId' => $doc_id, 'content' => $xml));
}

/*
 * view node (Implementation of hook_node_view in Drupal 7)
 */
function lingotek_node_view($node, $view_mode) {
  global $_lingotek_client, $_lingotek_locale;

  if ($node->tnid && $node->tnid != $node->nid && $view_mode == 'full') {
    if (lingotek_do_cache() && ($cache = cache_get('lingotek_' + $node->nid + '_link')) && !empty($cache->data) && time() < $cache->expire) {
      $link = $cache->data;
    }
    else {
      $doc_id = lingotek_lingonode($node->tnid, 'document_id');

      $output = $_lingotek_client->request('listTranslationTargets', array('documentId' => $doc_id));
      if ($output->results == "success") {
        $this_target;
        $phase_id;
        foreach ($output->translationTargets as $target) {
          if ($target->language == $_lingotek_locale[$node->language]) {
            $this_target = $target;
            break;
          }
        }
        $which_phase = 0;
        //Must be returned in order:
        foreach ($this_target->phases as $phase) {
          if ($phase->percentComplete < 100) {
            $phase_id = $phase->id;
            break;
          }
          $which_phase++;
        }

        //Should we download at this point automatically at 100%?:
        //TODO: This is delayed until a second refresh. Once to download, once to display changes...
        if ($which_phase == count($this_target->phases)) {
          if (!lingotek_lingonode($node->nid, "downloaded")) {
            $source_node = node_load(array('nid' => $node->tnid));
            lingotek_download_document($source_node, $node, TRUE);
            lingotek_lingonode($node->nid, "downloaded", TRUE);
          }
        }
        else {
          //We only want to give this message until they reach 100%:
          $message .= t("The translation of this page is still being worked on.") . " ";
          $message .= lingotek_workbench_phase_link($doc_id, $phase_id, t("Help make it better."));
        }
      }

      $link = array(
        'which_phase' => $which_phase,
        'message' => $message,
      );
      cache_set('lingotek_' + $node->nid + '_link', $link, 'cache', time() + 900);
    }

    if ((user_access('translate content') && $link['which_phase'] == 0) || (user_access('review translations') && $link['which_phase'] != 0)) {
      drupal_set_message($link['message']);
    }
  }
}

/*
 * delete node (Implementation of hook_node_delete in Drupal 7)
 */
function lingotek_node_delete($node) {
  global $_lingotek_client, $_lingotek_locale;

  //Handle cleanup of target languages
  //Node is the source language, so no need to remove a target language.
  $tnid = lingotek_lingonode($node->nid, 'tnid');
  if ($tnid) {
    $doc_id = lingotek_lingonode($tnid, 'document_id');

    $output = $_lingotek_client->request('getDocument', array('documentId' => $doc_id));
    if ($output->results == "success") {
      foreach ($output->translationTargets as $target) {
        if ($target->language == $_lingotek_locale[$node->language]) {
          $_lingotek_client->request('removeTranslationTarget', array('translationTargetId' => $target->id));
        }
      }
    }
  }
}

/*
 * insert node (Implementation of hook_node_insert in Drupal 7)
 *
 * Handle saving the phaseTemplate from the form on a new node's creation.
 */
function lingotek_node_insert($node) {
  if (isset($node->phaseTemplate)) {
    lingotek_lingonode($node->nid, 'phaseTemplate', $node->phaseTemplate);
  }
}

/*
 * Implementation of hook_menu_link_alter
 *
 * Menu Overwriting functionality (Requires the Menu Translation in i18n to be
 * enabled and it's setting enabled within this module)
 *
 * Determines if lingotek_translated_menu_link_alter will be called on a link.
 */
function lingotek_menu_link_alter(&$item, $menu) {
  if ($item['external'] == "0" && $item["access_callback"] == "node_access") {
    $item['options']['alter'] = TRUE;
  }
}

/*
 * Implementation of hook_translated_menu_link_alter
 *
 * Menu Overwriting functionality (Requires the Menu Translation in i18n to be
 * enabled and it's setting enabled within this module)
 *
 * Alters the link so that Menus correctly point to target languages when the
 * user is it's language instead of pointing to the source language's node
 */
function lingotek_translated_menu_link_alter(&$item, $menu) {
  global $language;

  if ($item["menu_name"] != "navigation" && variable_get('lingotek_menu_overwrite', FALSE)) {

    $nid = str_replace(str_replace("%", "", $item['router_path']), "", $item['link_path']);
    $node = lingotek_get_node($language->prefix, $nid);
    if ($node && $node->title != "") {
      $item['href'] = str_replace("%", $node->nid, $item['router_path']);
      $item['link_title'] = check_plain($node->title);
    }
  }
}

/*
 * Implementation of hook_init
 * flush the queue for machine translation on every page load
 */
function lingotek_init() {
  $menu = menu_get_active_trail();
  //Skip AJAX calls
  if ("" != $menu[1]['title']) {
    lingotek_dequeue();
  }
}

/*
 * Implementation of hook_help
 */
function lingotek_help($path, $arg) {
  switch ($path) {
    case 'admin/help#lingotek':
      return t('Please see our DevZone:') . ' ' . l(t('Drupal Integration'), 'http://lingotek.com/support/devzone/drupal-integration');
  }
}
